import os
import json
import threading
import time
from concurrent.futures import ThreadPoolExecutor
from django.core.management.base import BaseCommand
from django.db import transaction
from django.conf import settings
from django.contrib.auth import get_user_model
from google import genai
from google.genai import types

# Import your specific models
from lessons.models import Lesson
from homework.models import (
    Exercise, Question, QuestionChoice, 
    FillBlank, FillBlankOption, 
    OrderingItem, MatchingPair
)

# --- CONFIGURATION ---
API_KEY = "AIzaSyCiUithPuXgVwXzXr5MRg-g7xzQijBSLes"  # <--- PUT YOUR KEY HERE
MODEL_NAME = "gemini-2.5-flash" # Standard Flash (Better reasoning than Lite)
MAX_WORKERS = 15  # Parallel threads

# --- STATISTICS ---
stats = {
    "processed": 0,
    "failed": 0,
    "skipped": 0,
    "questions_created": 0
}
stats_lock = threading.Lock()

client = genai.Client(api_key=API_KEY)

class Command(BaseCommand):
    help = 'Upgrades exercises using Gemini 2.5 Flash for advanced question types'

    def handle(self, *args, **options):
        self.stdout.write(self.style.WARNING("Starting Content Upgrade..."))
        
        # 1. Get Admin User
        User = get_user_model()
        admin_user = User.objects.filter(is_superuser=True).first()
        if not admin_user:
            self.stdout.write(self.style.ERROR("No Superuser found."))
            return

        # 2. Fetch Lessons that have content
        # We only want lessons that have a Markdown resource
        lessons = Lesson.objects.filter(
            resources__resource_type='markdown',
            is_active=True
        ).distinct()

        total_count = lessons.count()
        self.stdout.write(f"Found {total_count} lessons to upgrade.")

        # 3. Process in Parallel
        with ThreadPoolExecutor(max_workers=MAX_WORKERS) as executor:
            # We map the process_lesson function to all lessons
            futures = [
                executor.submit(self.process_lesson, lesson, admin_user) 
                for lesson in lessons
            ]
            
            # Monitor progress
            while any(f.running() for f in futures):
                with stats_lock:
                    self.stdout.write(
                        f"Progress: {stats['processed']}/{total_count} | "
                        f"Questions Created: {stats['questions_created']} | "
                        f"Failed: {stats['failed']}", 
                        ending='\r'
                    )
                time.sleep(1)

        self.stdout.write(self.style.SUCCESS(f"\nUPGRADE COMPLETE."))

    def process_lesson(self, lesson, admin_user):
        """Worker function to process a single lesson"""
        try:
            # Get the markdown content
            resource = lesson.resources.filter(resource_type='markdown').first()
            if not resource or not resource.markdown_content:
                with stats_lock: stats['skipped'] += 1
                return

            content_snippet = resource.markdown_content[:15000] # Limit context size if needed

            # --- GENERATE WITH GEMINI ---
            prompt = self.get_prompt(lesson.title, content_snippet)
            
            response = client.models.generate_content(
                model=MODEL_NAME,
                contents=[prompt],
                config=types.GenerateContentConfig(
                    response_mime_type="application/json"
                )
            )
            
            # Parse JSON
            try:
                data = json.loads(response.text)
            except json.JSONDecodeError:
                # Retry once logic could go here, but for now we log failure
                with stats_lock: stats['failed'] += 1
                return

            # --- DB UPDATE (ATOMIC) ---
            with transaction.atomic():
                # 1. Delete OLD Exercises for this lesson
                # This wipes the "bad" exercises created by the previous script
                lesson.exercises.all().delete()

                # 2. Create NEW Exercise Container
                exercise = Exercise.objects.create(
                    lesson=lesson,
                    title=f"Evaluations: {lesson.title}",
                    description="Comprehensive exercises generated by Gemini 2.5",
                    exercise_format='mixed', # Mixed types
                    difficulty_level='medium',
                    is_published=True,
                    is_active=True,
                    auto_grade=True,
                    created_by=admin_user
                )

                # 3. Create Questions
                q_count = 0
                for idx, q_data in enumerate(data):
                    self.create_question(exercise, q_data, idx + 1)
                    q_count += 1

                with stats_lock:
                    stats['processed'] += 1
                    stats['questions_created'] += q_count

        except Exception as e:
            # print(f"Error processing {lesson.id}: {e}") # Uncomment for debug
            with stats_lock: stats['failed'] += 1

    def create_question(self, exercise, data, order):
        """Parses the JSON object and creates the correct Django models"""
        q_type = data.get('type')
        q_text = data.get('question')
        
        if not q_text: return

        # Map JSON type to Django Model Choice
        model_q_type = 'qcm_single' # Default
        if q_type == 'multiple_choice': model_q_type = 'qcm_multiple'
        elif q_type == 'true_false': model_q_type = 'true_false'
        elif q_type == 'fill_blank': model_q_type = 'fill_blank'
        elif q_type == 'ordering': model_q_type = 'ordering'
        elif q_type == 'matching': model_q_type = 'matching'

        # Create Question
        question = Question.objects.create(
            exercise=exercise,
            question_type=model_q_type,
            question_text=q_text,
            points=1, # Default point
            order=order
        )

        # --- HANDLE SUB-MODELS ---
        
        # 1. QCM / True-False
        if model_q_type in ['qcm_single', 'qcm_multiple', 'true_false']:
            choices = data.get('choices', [])
            for c_idx, choice in enumerate(choices):
                QuestionChoice.objects.create(
                    question=question,
                    choice_text=choice.get('text', ''),
                    is_correct=choice.get('correct', False),
                    order=c_idx + 1
                )

        # 2. Ordering
        elif model_q_type == 'ordering':
            items = data.get('items', [])
            for item in items:
                OrderingItem.objects.create(
                    question=question,
                    text=item.get('text', ''),
                    correct_position=item.get('position', 1)
                )

        # 3. Matching
        elif model_q_type == 'matching':
            pairs = data.get('pairs', [])
            for p_idx, pair in enumerate(pairs):
                MatchingPair.objects.create(
                    question=question,
                    left_text=pair.get('left', ''),
                    right_text=pair.get('right', ''),
                    order=p_idx + 1
                )

        # 4. Fill in the Blanks
        elif model_q_type == 'fill_blank':
            blanks = data.get('blanks', [])
            for b_data in blanks:
                # Create the Blank placeholder
                blank_obj = FillBlank.objects.create(
                    question=question,
                    order=b_data.get('order', 1),
                    label=f"Blank {b_data.get('order', 1)}"
                )
                
                # Create the Correct Option
                correct_txt = b_data.get('correct_option')
                if correct_txt:
                    FillBlankOption.objects.create(
                        blank=blank_obj,
                        option_text=correct_txt,
                        is_correct=True,
                        order=1
                    )
                
                # Create Distractors (Wrong options for dropdowns)
                distractors = b_data.get('distractors', [])
                for d_idx, d_text in enumerate(distractors):
                    FillBlankOption.objects.create(
                        blank=blank_obj,
                        option_text=d_text,
                        is_correct=False,
                        order=d_idx + 2
                    )

    def get_prompt(self, title, content):
        return f"""
        You are an educational expert. Create a JSON list of exercises based on the lesson below.
        
        **Rules:**
        1. **Language:** The output MUST be in the same language as the lesson text (Arabic or French).
        2. **Variety:** Generate a mix of Question Types:
           - 'single_choice' (Classic MCQ)
           - 'true_false'
           - 'ordering' (Arrange steps or chronological events)
           - 'matching' (Match terms to definitions)
           - 'fill_blank' (Complete sentences)
        3. **Math:** If there are formulas, use simple text or standard LaTeX double escaped (\\\\frac).
        4. **Quantity:** Generate exactly 5 high-quality questions.

        **Lesson Title:** {title}
        **Lesson Content:**
        {content}

        **Required JSON Schema (Array of Objects):**
        [
            {{
                "type": "single_choice", 
                "question": "...", 
                "choices": [{{"text": "Option A", "correct": false}}, {{"text": "Option B", "correct": true}}]
            }},
            {{
                "type": "true_false", 
                "question": "...", 
                "choices": [{{"text": "Vrai", "correct": true}}, {{"text": "Faux", "correct": false}}]
            }},
            {{
                "type": "ordering",
                "question": "Arrange the following...",
                "items": [{{"text": "First Step", "position": 1}}, {{"text": "Second Step", "position": 2}}]
            }},
            {{
                "type": "matching",
                "question": "Match the terms...",
                "pairs": [{{"left": "Term A", "right": "Def A"}}, {{"left": "Term B", "right": "Def B"}}]
            }},
            {{
                "type": "fill_blank",
                "question": "Complete the sentence with the correct term.",
                "blanks": [
                    {{
                        "order": 1,
                        "correct_option": "Gravity",
                        "distractors": ["Mass", "Speed"]
                    }}
                ]
            }}
        ]
        """